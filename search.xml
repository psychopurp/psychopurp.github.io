<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>开始写博客的第一天</title>
    <url>/2021/04/09/first-day/</url>
    <content><![CDATA[<p>今年是大四的最后一个学期，之前没有自己写博客的想法，直到最近感觉自己的知识很碎片化，也很容易忘记之前学过的一些东西，故有了写博客来记录的想法，不仅仅用来记录学到的知识，也会记录一些面试经历，工作体验，有趣的项目分享，算法学习还有一些生活上的碎碎念。</p>
<p>第一次写博客，昨天花了半天时间把博客搭建好，并部署到了 github pages，结果发现 github pages 无法在微博上进行分享，以后在想办法搞个域名，先就这这样搞着。</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
  <entry>
    <title>2021百度校招+后端开发面试</title>
    <url>/2021/04/12/baidu-interview/</url>
    <content><![CDATA[<p>大四上学期一直在字节跳动实习，期间也没参加其他公司的秋招，今年四月份想再看看春招有没有更好的机会，前几天在一个 Golang 交流群里看到了一个百度的机会，看介绍是个 955，而且挺核心的一个技术团队，技术栈也是 go。于是直接给那个邮箱投了简历，第二天就给我打来了电话，约了下周一的面试。</p>
<hr>
<h1 id="一面-技术面（90-分钟左右）"><a href="#一面-技术面（90-分钟左右）" class="headerlink" title="一面 技术面（90 分钟左右）"></a>一面 技术面（90 分钟左右）</h1><p>一面让我下载了他们的工作平台：如流（类似飞书），使用此软件来进行视频面试。面试官很专业，问题主要分为项目，计算机基础，算法等部分，最后给了我面试评价，以及让我问了一些问题。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最开始自我介绍，我大概介绍了下学校和专业，以及去年的实习经历和实习所做的一些工作。</p>
<h3 id="1-项目相关"><a href="#1-项目相关" class="headerlink" title="1.项目相关"></a>1.项目相关</h3><p>项目相关问题都是根据我实习工作来提问的</p>
<ol>
<li>你做项目遇到的最难的问题是什么？（以前没咋思考过这个问题，就说了一个做的比较复杂的项目）</li>
<li>rocket mq 选择某个组件详细介绍原理？（讲了 broker,producer,consumer 相关一些联系</li>
<li>rocket mq 如何保证消息传递？</li>
<li>consumer 能否知道自己消费到哪里了？</li>
<li>redis 基础数据结构？使用过哪些？有几种数据持久化方案？RDB 和 AOF 区别？</li>
</ol>
<h3 id="2-计算机基础"><a href="#2-计算机基础" class="headerlink" title="2.计算机基础"></a>2.计算机基础</h3><ol>
<li>进程和线程的关系？</li>
<li>如何查找 CPU 占用资源高的进程？如何查看端口占用情况？<blockquote>
<p>讲了 linux 的 top，lsof -i，netstat -nltp 相关的命令。</p>
</blockquote>
</li>
<li>如何查找僵尸进程？<blockquote>
<p>这个记得有个 linux 命令可以查询，但是面试没想起来</p>
</blockquote>
</li>
<li>TCP 三次握手是怎样进行的？</li>
<li>TCP 为什么是可靠的传输协议？拥塞控制介绍？</li>
<li>HTTP 常见状态码？</li>
<li>HTTP 和 HTTPS 有什么区别？HTTPS 的连接过程？是对称加密还是非对称加密？<blockquote>
<p>https 的原理和区别回答出来了，但是 SSL 层认证的详细过程记得不清楚，大致讲了一下，结果最后不确定是对称加密还是非对称加密 😓</p>
</blockquote>
</li>
<li>HTTP2.0 和 HTTP1.0 的区别？<blockquote>
<p>这两个区别好久前看过，回答的不太好。</p>
</blockquote>
</li>
<li>从输入网址到获得页面的过程？DNS 是怎么进行查询的？<blockquote>
<p>DNS 讲了使用递归查询。记得也有点模糊了。</p>
</blockquote>
</li>
<li>如何实现分片下载和分片上传？<blockquote>
<p>还好之前自己写过分片下载，知道原理，这块回答的好。</p>
</blockquote>
</li>
<li>数据库索引引擎有哪些？有什么区别？<blockquote>
<p>数据库问的都是 mysql 相关的。讲了 innodb 和 myisam,和一些基本区别。</p>
</blockquote>
</li>
<li>数据库的四种隔离级别？如何实现可重复读？MVCC 介绍原理？<blockquote>
<p>隔离级别都讲出来了，实现可重复读回答了 mvcc，但 mvcc 原理没答出来。</p>
</blockquote>
</li>
<li>为什么索引引擎使用 B+树而不是二叉树？使用二叉树为什么会效率低？<blockquote>
<p>B+树的话扁平 IO 次数少，而且命中索引后可以读入大块数据到内存，二叉树因为结构导致 IO 次数非常高。</p>
</blockquote>
</li>
</ol>
<h3 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h3><p>因为简历里有写过使用前缀树解决了一个实际业务问题，面试官就让我在线写一个前缀树。我就共享屏幕用 golang 写了一个，不过费了点时间。写完跑了测试并给他讲解了下思路。</p>
<h4 id="实现一个前缀树"><a href="#实现一个前缀树" class="headerlink" title="实现一个前缀树"></a>实现一个前缀树</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> Node <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Prefix <span class="token builtin">int32</span>
    Full   <span class="token builtin">string</span>
    IsEnd  <span class="token builtin">bool</span>
    Nodes  <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int32</span><span class="token punctuation">]</span><span class="token operator">*</span>Node
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Trie <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Root <span class="token operator">*</span>Node
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>Trie<span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span>item <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> t<span class="token punctuation">.</span>Root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		t<span class="token punctuation">.</span>Root <span class="token operator">=</span> <span class="token operator">&amp;</span>Node<span class="token punctuation">{</span>
			Prefix<span class="token punctuation">:</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
			Full<span class="token punctuation">:</span>   <span class="token string">""</span><span class="token punctuation">,</span>
			IsEnd<span class="token punctuation">:</span>  <span class="token boolean">false</span><span class="token punctuation">,</span>
			Nodes<span class="token punctuation">:</span>  <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int32</span><span class="token punctuation">]</span><span class="token operator">*</span>Node<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	node <span class="token operator">:=</span> t<span class="token punctuation">.</span>Root
	<span class="token keyword">for</span> index<span class="token punctuation">,</span> char <span class="token operator">:=</span> <span class="token keyword">range</span> item <span class="token punctuation">{</span>
		<span class="token comment">// 如果存在则获取子节点</span>
		<span class="token keyword">if</span> tmp<span class="token punctuation">,</span> exist <span class="token operator">:=</span> node<span class="token punctuation">.</span>Nodes<span class="token punctuation">[</span>char<span class="token punctuation">]</span><span class="token punctuation">;</span> exist <span class="token punctuation">{</span>
			node <span class="token operator">=</span> tmp
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token comment">// 如果不存在则插入,并进入子节点</span>
			node<span class="token punctuation">.</span>Nodes<span class="token punctuation">[</span>char<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Node<span class="token punctuation">{</span>
				Prefix<span class="token punctuation">:</span> char<span class="token punctuation">,</span>
				Full<span class="token punctuation">:</span>   item<span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">:</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
				IsEnd<span class="token punctuation">:</span>  <span class="token boolean">false</span><span class="token punctuation">,</span>
				Nodes<span class="token punctuation">:</span>  <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int32</span><span class="token punctuation">]</span><span class="token operator">*</span>Node<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 如果是最后一个字符，则设置结束符号</span>
			<span class="token keyword">if</span> index <span class="token operator">==</span> <span class="token function">len</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span>
				node<span class="token punctuation">.</span>Nodes<span class="token punctuation">[</span>char<span class="token punctuation">]</span><span class="token punctuation">.</span>IsEnd <span class="token operator">=</span> <span class="token boolean">true</span>
			<span class="token punctuation">}</span>
			node <span class="token operator">=</span> node<span class="token punctuation">.</span>Nodes<span class="token punctuation">[</span>char<span class="token punctuation">]</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>Trie<span class="token punctuation">)</span> <span class="token function">PrefixSearch</span><span class="token punctuation">(</span>prefix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node <span class="token punctuation">{</span>
	node <span class="token operator">:=</span> t<span class="token punctuation">.</span>Root
	<span class="token keyword">var</span> result <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node

	<span class="token comment">// 先找出该prefix 的子节点</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> char <span class="token operator">:=</span> <span class="token keyword">range</span> prefix <span class="token punctuation">{</span>
		<span class="token keyword">if</span> tmp<span class="token punctuation">,</span> exist <span class="token operator">:=</span> node<span class="token punctuation">.</span>Nodes<span class="token punctuation">[</span>char<span class="token punctuation">]</span><span class="token punctuation">;</span> exist <span class="token punctuation">{</span>
			node <span class="token operator">=</span> tmp
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> node <span class="token operator">==</span> t<span class="token punctuation">.</span>Root <span class="token punctuation">{</span>
		<span class="token keyword">return</span> result
	<span class="token punctuation">}</span>

	<span class="token function">DFS</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>result<span class="token punctuation">)</span>
	<span class="token keyword">return</span> result
<span class="token punctuation">}</span>

<span class="token comment">// 找出该子节点下所有IsEnd 节点</span>
<span class="token keyword">func</span> <span class="token function">DFS</span><span class="token punctuation">(</span>node <span class="token operator">*</span>Node<span class="token punctuation">,</span> result <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> node <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> node<span class="token punctuation">.</span>Nodes <span class="token punctuation">{</span>
		<span class="token keyword">if</span> n<span class="token punctuation">.</span>IsEnd <span class="token punctuation">{</span>
			<span class="token operator">*</span>result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token function">DFS</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">GenerateTrie</span><span class="token punctuation">(</span>data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>Trie <span class="token punctuation">{</span>

	trie <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Trie<span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> data <span class="token punctuation">{</span>
		trie<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> trie
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	data <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"hex"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token string">"war"</span><span class="token punctuation">,</span> <span class="token string">"water"</span><span class="token punctuation">}</span>
	trie <span class="token operator">:=</span> <span class="token function">GenerateTrie</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>

	nodes <span class="token operator">:=</span> trie<span class="token punctuation">.</span><span class="token function">PrefixSearch</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> nodes <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v "</span><span class="token punctuation">,</span> n<span class="token punctuation">.</span>Full<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>

	nodes <span class="token operator">=</span> trie<span class="token punctuation">.</span><span class="token function">PrefixSearch</span><span class="token punctuation">(</span><span class="token string">"he"</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> n <span class="token operator">:=</span> <span class="token keyword">range</span> nodes <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v "</span><span class="token punctuation">,</span> n<span class="token punctuation">.</span>Full<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//fmt.Println("hello",nodes)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>最后面试官告诉我需要再看一下 https 加解密实现的流程，以及 mysql mvcc 如何实现可重复读隔离级别的相关内容。面试官很 nice，最后自己把 https 的加解密给我讲解了一下。</p>
<p>然后我提问了一些他们团队所做的事相关的问题就结束了</p>
<hr>
<h1 id="二面-技术面（70-分钟左右）"><a href="#二面-技术面（70-分钟左右）" class="headerlink" title="二面 技术面（70 分钟左右）"></a>二面 技术面（70 分钟左右）</h1><p>周一刚面完，周二 HR 就找我约了周三的面试，也是同一个时间点，因为一面让我下去再看看 https 和 mysql 的 mvcc 相关内容，我怕二面又来问我这个，就好好准备了这两块内容，但二面没有问基础内容，全程聊了项目和工程，后面是共享屏幕来介绍我的个人项目和算法代码，最后讲了两道 leetcode hard 算法题。</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>二面问题基本围绕着我在简历上写的项目进行的，所以中间一些详细的问题就略过啦。</p>
<h3 id="1-项目相关-1"><a href="#1-项目相关-1" class="headerlink" title="1.项目相关"></a>1.项目相关</h3><ol>
<li>你做的项目是部署到了多少台机器？(这个应该是想问我做的项目的规模</li>
<li>分布式系统中怎么实现幂等性？可靠性？</li>
<li>redis 熟悉吗？有哪些基本数据结构？</li>
<li>你用 go 写过并发程序吗？要怎么做？<blockquote>
<p>这个应该是考察语言熟悉程度，回答了 sync.Mutex,sync.Map 之类的使用，以及并发程序需要注意的点。</p>
</blockquote>
</li>
<li>如何给 go net/http 实现的接口添加一个中间件？</li>
<li>如果让你设计一个中间件的功能你会使用什么数据结构？你会怎么实现？<blockquote>
<p>之前学习 gin 框架 的时候模仿写过一个 web 框架，就介绍了这个项目中实现中间件的源码和思路。</p>
</blockquote>
</li>
</ol>
<h3 id="2-算法"><a href="#2-算法" class="headerlink" title="2.算法"></a>2.算法</h3><ol>
<li>你最近刷过哪些算法题？来讲讲几个？<blockquote>
<p>面试官应该是看了我的 github，刚好最近在研究两道 hard 级别的题，我就打开介绍了下我写的思路，优化的点，以及多种解决方法。</p>
</blockquote>
</li>
</ol>
<h2 id="最后总结-1"><a href="#最后总结-1" class="headerlink" title="最后总结"></a>最后总结</h2><ul>
<li>二面是来考察我实际做项目的能力，以及我对语言的熟悉程度，很多点都是根据我在简历上写的经历来提问，比如：这么做是为了解决什么问题？如果 xxx，你怎么处理？有没有考虑 xxx 点？之类的。</li>
<li>二面基本没有失误，自己也感觉发挥的很好，期间问的一些问题没理解面试官意思，面试官也不急不躁给我讲解，后面我问问题的环节就问了一些关于工作环境，团队规模之类的。面试体验也很好，心想应该没问题了，果然过了两小时 HR 就来跟我约周四的第三次面试了。</li>
</ul>
<h1 id="三面-Leader-面（60-分钟左右）"><a href="#三面-Leader-面（60-分钟左右）" class="headerlink" title="三面 Leader 面（60 分钟左右）"></a>三面 Leader 面（60 分钟左右）</h1><p>三面是部门 leader，主要聊了人生经历，以及今后规划等。最后是展示自己的一个项目，并从中提问题。</p>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><ol>
<li>一致性哈希存在哪些问题？</li>
<li>设计中间件需要遵循哪些原则？<br>…</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>后端开发</tag>
        <tag>百度</tag>
      </tags>
  </entry>
  <entry>
    <title>数独生成器</title>
    <url>/2021/04/12/sudoku-player/</url>
    <content><![CDATA[<h1 id="实现一个能够生成数独游戏并求解数独问题的控制台程序"><a href="#实现一个能够生成数独游戏并求解数独问题的控制台程序" class="headerlink" title="实现一个能够生成数独游戏并求解数独问题的控制台程序"></a>实现一个能够生成数独游戏并求解数独问题的控制台程序</h1><h2 id="具体要求"><a href="#具体要求" class="headerlink" title="具体要求"></a>具体要求</h2><ul>
<li>采用 c++语言实现</li>
<li>能够生成数独，并存至文件</li>
<li>读取文件内的数独，求解并将结果输出至文件</li>
<li>命令行功能</li>
</ul>
<p><img src="/2021/04/12/sudoku-player/%E6%95%B0%E7%8B%AC%E7%94%9F%E6%88%90%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0.jpg" alt="命令行参数"></p>
<hr>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>使用回溯算法完成数独的求解与生成。<br>GitHub 仓库 : <a href="https://github.com/psychopurp/sudoku-player">sudoku-player</a></p>
<h2 id="数独的规则"><a href="#数独的规则" class="headerlink" title="数独的规则"></a>数独的规则</h2><p>数独的形式是下面这样的，一共有 81 个格子。<br><img src="https://file.lifeni.life/markdown/algorithm-sudoku/sudoku.svg" alt="数独"><br>解数独时需要根据 9×9 盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫（3*3）内的数字均含 1-9，不重复。</p>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><blockquote>
<p>回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li>找到一个可能存在的正确的答案</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案</li>
</ul>
</blockquote>
<h2 id="数独的解法"><a href="#数独的解法" class="headerlink" title="数独的解法"></a>数独的解法</h2><p>使用回溯算法来求解数独。</p>
<h3 id="解数独思路"><a href="#解数独思路" class="headerlink" title="解数独思路"></a>解数独思路</h3><p>类似人的思考方式去尝试，行，列，还有 3*3 的方格内数字是 1~9 不能重复。</p>
<p>我们尝试填充，如果发现重复了，那么擦除重新进行新一轮的尝试，直到把整个数组填充完成。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul>
<li>数独首先行，列，还有 3*3 的方格内数字是 1~9 不能重复。</li>
<li>声明布尔数组，表明行列中某个数字是否被使用了， 被用过视为 true，没用过为 false(该部分使用 bitset 来进行优化 000001010 表示 2 和 4 已经存在了)。</li>
<li>初始化布尔数组，表明哪些数字已经被使用过了。</li>
<li>尝试去填充数组，只要行，列，还有 3*3 的方格内出现已经被使用过的数字，我们就不填充，否则尝试填充。</li>
<li>如果填充失败，那么我们需要回溯。将原来尝试填充的地方改回来。</li>
<li>递归直到数独被填充完成。</li>
</ul>
<h3 id="数独求解代码（C-）"><a href="#数独求解代码（C-）" class="headerlink" title="数独求解代码（C++）"></a>数独求解代码（C++）</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*
数独
char data[9][9] = {
    {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
    {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
    {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
    {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
    {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
    {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
    {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
    {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
    {'.', '.', '.', '.', '8', '.', '.', '7', '9'}};
*/
class SudokuPlayer
{
private:
    // 使用位运算来表示某个数是否出现过
    int rowUsed[N];
    int columnUsed[N];
    int blockUsed[N];

public:
    vector&lt;Board&gt; result;  // 存放求解的结果终盘
    vector&lt;pair&lt;int, int&gt; &gt; spaces; //存放被挖空的位置坐标

public:
    SudokuPlayer()
    {
        initState();
    }

    void initState()
    {
        memset(rowUsed, 0, sizeof(rowUsed));
        memset(columnUsed, 0, sizeof(columnUsed));
        memset(blockUsed, 0, sizeof(blockUsed));
        spaces.clear();
        result.clear();
    }

    void addResult(Board &amp;board)
    {
        vector&lt;vector&lt;char&gt; &gt; obj(board);
        result.push_back(obj);
    }

    // 位运算 设置i,j 位存在gitit
    void flip(int i, int j, int digit)
    {
        rowUsed[i] ^= (1 &lt;&lt; digit);
        columnUsed[j] ^= (1 &lt;&lt; digit);
        blockUsed[(i / 3) * 3 + j / 3] ^= (1 &lt;&lt; digit);
    }

    vector&lt;Board&gt; solveSudoku(Board board)
    {
        initState();
        for (int i = 0; i &lt; N; i++)
        {
            for (int j = 0; j &lt; N; j++)
            {
                // 数独的空位用 '.'  表示
                if (board[i][j] == '.')
                {
                    spaces.push_back(pair&lt;int, int&gt;(i, j));
                }
                else
                {
                    int digit = board[i][j] - '1';
                    // 数独终盘的i,j坐标存在 digit 数
                    flip(i, j, digit);
                }
            }
        }
        DFS(board, 0);
        return result;
    }
    // DFS 进行回溯
    void DFS(Board &amp;board, int pos)
    {
        if (pos == spaces.size())
        {
            addResult(board);
            return;
        }
        int i = spaces[pos].first;
        int j = spaces[pos].second;
        // mask 能查询出 i,j 的位置不能放哪些数
        int mask = ~(rowUsed[i] | columnUsed[j] | blockUsed[(i / 3) * 3 + j / 3]) &amp; 0x1ff;
        int digit = 0;
        while (mask)
        {
            if (mask &amp; 1)
            {
                flip(i, j, digit);
                board[i][j] = '1' + digit;
                DFS(board, pos + 1);
                flip(i, j, digit);
            }
            mask = mask &gt;&gt; 1;
            digit++;
        }
    }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>完整代码 <a href="https://github.com/psychopurp/sudoku-player">sudoku-player</a></p>
<h2 id="生成数独"><a href="#生成数独" class="headerlink" title="生成数独"></a>生成数独</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先生成一个完整的数独终盘，之后随机挖取一个数字，并尝试求解，如果能求出唯一解则说明该数独合法，不能求解则再还原之前的数字并重新随机挖取。重复以上流程直到 N 个数被挖取。</p>
<p>参考了网上的一种做法，从一个九宫格出发，通过矩阵变换得到其他九宫格，从而获得整体数独。</p>
<p>首先，在中间的宫格生成一个随机的排列：<br><img src="/2021/04/12/sudoku-player/%E6%95%B0%E7%8B%AC%E7%BB%88%E7%9B%981.png" alt="数独终盘1"></p>
<p>第二步，将中间的宫格向两侧作行变换扩展（注意，原本 0-1-2 的行排列做变换后只有 1-2-0 和 2-0-1 的排列是符合数独规则的，列变换也是一样）<br><img src="/2021/04/12/sudoku-player/%E6%95%B0%E7%8B%AC%E7%BB%88%E7%9B%982.png" alt="数独终盘2"></p>
<p>中间的格子列变换生成上下的宫格：<br><img src="/2021/04/12/sudoku-player/%E6%95%B0%E7%8B%AC%E7%BB%88%E7%9B%983.png" alt="数独终盘3"></p>
<p>然后，（这一步其实可以替换为不同的做法），使用左右两个宫格进行行变换，分别上下拓展。<br><img src="/2021/04/12/sudoku-player/%E6%95%B0%E7%8B%AC%E7%BB%88%E7%9B%984.png" alt="数独终盘4"></p>
<p>这一个做法优缺点如下：</p>
<p>优点：十分高效，并且能够确保生成合法的数独。</p>
<p>缺点：生成的数独的宫格之间的相似性较强，符合一定的模式，不能穷举所有的数独（不过，通过这种方法生成的数独大概在 9!*2^4 个，大约五百多万，而数独一共有：6670903752021072936960 个）</p>
<p>参考：</p>
<ul>
<li><a href="http://www.afjarvis.staff.shef.ac.uk/sudoku/sudoku.pdf">论文 Enumerating possible Sudoku grids</a></li>
<li><a href="https://riroaki.github.io/Sudoku-Auto-Player/">博客 图片来源</a></li>
</ul>
<h3 id="数独生成代码（C-）"><a href="#数独生成代码（C-）" class="headerlink" title="数独生成代码（C++）"></a>数独生成代码（C++）</h3><p>给出关键的几个函数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class SudokuPlayer
{
public:
    // 验证生成的数独是否符合数独的规则
    bool checkBoard(Board &amp;board)
    {
        initState();
        for (int i = 0; i &lt; 9; i++)
        {
            for (int j = 0; j &lt; 9; j++)
            {
                if (board[i][j] != '.')
                {
                    int digit = board[i][j] - '1';
                    if ((rowUsed[i] | columnUsed[j] | blockUsed[(i / 3) * 3 + j / 3]) &amp; (1 &lt;&lt; digit))
                    {
                        return false;
                    }
                    flip(i, j, digit);
                }
            }
        }
        return true;
    }

    // 生成数独终盘，并从中挖去 digCount 个数
    Board generateBoard(int digCount)
    {
        vector&lt;vector&lt;char&gt; &gt; board(N, vector&lt;char&gt;(N, '.'));
        // 生成0-8的数，位置随机
        vector&lt;int&gt; row = getRand9();
        for (int i = 0; i &lt; 3; i++)
        {
            board[3][i + 3] = row[i] + '1';
            board[4][i + 3] = row[i + 3] + '1';
            board[5][i + 3] = row[i + 6] + '1';
        }
        // 以下四个步骤就是上面的矩阵变换
        copySquare(board, 3, 3, true);
        copySquare(board, 3, 3, false);
        copySquare(board, 3, 0, false);
        copySquare(board, 3, 6, false);

        // 挖取操作
        while (digCount)
        {
            int x = rand() % 9;
            int y = rand() % 9;
            if (board[x][y] == '.')
                continue;
            char tmp = board[x][y];
            board[x][y] = '.';
            solveSudoku(board);
            if (result.size() == 1)
            {
                digCount--;
            }
            else
            {
                board[x][y] = tmp;
            }
        }
        if (!checkBoard(board))
        {
            cout &lt;&lt; "wrong board" &lt;&lt; endl;
        }

        return board;
    }
    // 获取包含0-8的随机数组
    vector&lt;int&gt; getRand9()
    {
        vector&lt;int&gt; result;
        int digit = 0;
        while (result.size() != 9)
        {
            int num = rand() % 9;
            if ((1 &lt;&lt; num) &amp; digit)
            {
                continue;
            }
            else
            {
                result.push_back(num);
                digit ^= (1 &lt;&lt; num);
            }
        }
        return result;
    }
    // 矩阵变换 将左上角坐标(src_x,src_y)的3x3矩阵进行列扩展或者行扩展。isRow 为是否是行扩展
    void copySquare(Board &amp;board, int src_x, int src_y, bool isRow)
    {
        int rand_tmp = rand() % 2 + 1;
        int order_first[3] = {1, 2, 0};
        int order_second[3] = {2, 0, 1};
        if (rand_tmp == 2)
        {
            order_first[0] = 2;
            order_first[1] = 0;
            order_first[2] = 1;
            order_second[0] = 1;
            order_second[1] = 2;
            order_second[2] = 0;
        }
        for (int i = 0; i &lt; 3; i++)
        {
            if (isRow)
            {
                board[src_x][i] = board[src_x + order_first[0]][src_y + i];
                board[src_x + 1][i] = board[src_x + order_first[1]][src_y + i];
                board[src_x + 2][i] = board[src_x + order_first[2]][src_y + i];
                board[src_x][i + 6] = board[src_x + order_second[0]][src_y + i];
                board[src_x + 1][i + 6] = board[src_x + order_second[1]][src_y + i];
                board[src_x + 2][i + 6] = board[src_x + order_second[2]][src_y + i];
            }
            else
            {
                board[i][src_y] = board[src_x + i][src_y + order_first[0]];
                board[i][src_y + 1] = board[src_x + i][src_y + order_first[1]];
                board[i][src_y + 2] = board[src_x + i][src_y + order_first[2]];
                board[i + 6][src_y] = board[src_x + i][src_y + order_second[0]];
                board[i + 6][src_y + 1] = board[src_x + i][src_y + order_second[1]];
                board[i + 6][src_y + 2] = board[src_x + i][src_y + order_second[2]];
            }
        }
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>至此，数独的生成和求解算法已完成。其次命令行功能也在<a href="https://github.com/psychopurp/sudoku-player">源码</a>中给出了实现。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
